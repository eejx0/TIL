## 객체 지향 & 프로토타입

### 프로토타입 ?

<aside>
⚙ 다른 객체의 원형이 되는 객체로서 **객체 간의 상속을 가능**하게 함

</aside>

→ 프로토 타입 기반 언어인 JS는..

변수나 객체의 의미가 그 변수나 객체가 속한 맥락에 의해서만 평가될 수 있기 때문에
공통된 속성을 기준으로 한 분류가 아닌 가장 좋은 보기(프로토타입)으로부터 객체 범주화

### 객체 지향

**객체란 💡**

> JS는 객체 기반의 프로그래밍 언어이며 JS를 이루는 거의 모든 것이 객체
> 

**어떤 변수**가 하나의 값을 가지는 것이 아니라 **여러 속성을 가지고** 이 속성들을 **한 곳에 묶어놓은 것**

**프로토타입 기반 객체 지향** 😯

> JS는 클래스 기반 OOP 언어보다 효율적이고 더 강력한 객체 지향 프로그래밍 능력을 지닌 프로토타입 기반의 객체 지향 프로그래밍 언어
> 

프로토타입을 기반으로 **상속을 구현**해 불필요한 중복 제거

→ 각 인스턴스마다 동일한 메서드를 각각 가지면 **효율적이지 못하니까**

## 동기 비동기

### 동기 vs 비동기

<aside>
⚙ **동기**는 **직렬적으로 작동**하는 방식
**비동기**는 **병렬적으로 작동**하는 방식

</aside>

- 비동기
    - 특정 코드가 끝날 때 까지 코드의 실행을 멈추지 않고 다음 코드를 먼저 실행하는 것
    - 요청을 보낸 후 응답의 수락 여부와는 상관없이 다음 태스크가 동작하는 방식
    - 비동기 요청 시 응답 후 처리할 콜백함수를 함께 알려줌 (태스크 완료 시 콜백함수 호출됨)
    - ex) Web API, Ajax, setTimeout 등
- 동기
    - 요청을 보낸 후 응답을 받아야지만 다음 동작이 이루어지는 방식
    - 실제로 Cpu가 느려지는 건 아니지만 시스템의 전체적인 효율이 저하됨

### 콜백 함수

> 콜백 패턴을 사용하면 처리 순서를 보장하기 위해 여러 콜백함수가 중첩되어 콜백지옥 발생
> 

→ 가독성을 나쁘게 해 실수를 유발하는 원인이 됨

### Promise

> 콜백 함수의 단점을 보완해 비동기 처리 시점을 명확하게 표현 가능 (ES6 도입)
> 

→ Promise 생성자 함수를 통해 인스턴스화 함

→ Promise 생성자 함수는 비동기 작업을 수행할 콜백함수를 인자로 전달받음

→ 이 콜백함수는 resolve와 reject 함수를 인자로 전달받음

```jsx
const promise = new Promise((resolve, reject) => {
	if (/*비동기 작업 수행 성공*/) {
		resolve('result');
	}
	else {
		/*비동기 작업 수행 실패*/
		reject('fail')
	}
})
```

- **pending**: 비동기 처리가 아직 수행되지 않은 상태
- **fulfilled**: 비동기 처리가 수행된 상태 (성공)
- **rejected**: 비동기 처리가 수행된 상태 (실패)
- **settled**: 비동기 처리가 수행된 상태 (성공 or 실패)
- **후속 처리 메소드**: then(프로미스 반환), catch(예외)
    - 메소드를 체이닝 해 여러 프로미스를 연결해 사용 가능
    - 콜백 지옥 해결

### Async Await

> 콜백함수와 프로미스의 단점을 보완하고 읽기 좋은 코드를 작성할 수 있게 도움
> 

→ 복잡했던 Promise를 좀 더 편하게 사용 가능

```jsx
async function 함수명() {
	await 비동기처리메서드이름();
}
```

- async
    - function 앞에 붙이면 해당 함수는 항상 프로미스 반환
    - 프로미스가 아닌 값을 반환해도 이행 상태의 프로미스로 값을 감싸 프로미스가 반환되도록
- await
    - async 함수 안에서만 작동
    - 프로미스가 처리될 때까지 함수 실행을 기다리게 만듦
    - 결과는 그 이후 반환됨
    - promise.then보다 가독성이 좋고 쓰기도 쉬움
- 에러
    - try… catch
    - 에러 발생 시 제어 흐름이 catch 블록으로 넘어감

## blocking, non blocking (동기 비동기)

제어권: 자신의 코드를 실행할 권리같은 것 

→ 이를 가지면 함수는 자신의 코드를 끝까지 실행한 후 자신을 호출한 함수에게 돌려줌

### blocking

A 함수가 B 함수롤 호출하면 제어권을 A가 호출한 B 함수에 넘겨줌

### non blocking

A 함수가 B 함수를 호출해도 제어권은 그대로 자신이 가지고 있음

### Sync-Blocking

A 함수는 B 함수의 **리턴값을 필요**로 함 (동기)

제어권을 B에게 넘겨주고 B가 실행을 완료해 **리턴값과 제어권을 돌려줄 때까지 기다림** (블로킹)

### Sync-Nonblocking

A 함수는 B 함수에게 제어권을 주지 않고 **자신의 코드를 계속 실행** (논블로킹)

A는 B의 리턴값이 필요해 중간중간 B에게 **실행을 완료했는지 물어봄** (동기)

### Async-Nonblocking

제어권을 B 함수에게 주지 않고 **자신이 계속 가지고 있음** (논블로킹)

B 함수를 호출할 때 콜백함수를 같이 줌
→ B는 자신의 작업이 끝나면 A 함수가 준 콜백 함수 실행 (비동기)

### Async-blocking

A 함수는 B 함수의 **리턴 값에 신경쓰지 않고 콜백함수** 보냄 (비동기)

B의 작업에 관심없음에도 불구하고 **A는 B에게 제어권을 넘김** (블로킹)

⇒ A는 자신과 관련없는 B의 작업이 끝날 때까지 기다려야 함
