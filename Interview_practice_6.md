## JavaScript ES6 변경된 내용

### ES6?

<aside>
💡 새로운 언어 기능이 포함된 주요 업데이트

</aside>

→ 2009년도에 표준화된 ES5 이후로 언어 기능에 대한 첫 업데이트

### ES6 기능

- const and let
    - const
        - 변수 선언을 위한 ES6의 새로운 키워드
        - 사용되면 변수를 다시 할당할 수 없음
        - 객체와 함께 사용할 때를 제외하고는 변경 불가능한 변수!
    - let
        - 새로운 값을 가질 수도 있고 재할당할 수도 있음
        - 변경 가능한 변수가 생성
- 화살표 함수
    - map, filter, reduce 등 내장 함수와 함께 사용 가능
- 템플릿 리터럴
    - 백틱을 사용해 문자열 내에서 변수 사용 가능
- 기본 매개 변수
    - 매개 변수를 쓰지 않은 경우 매개 변수가 이미 기본값에 정의되어 있음
    - 따라서 정의되지 않은 오류가 반환되지 않음
- 배열 및 객체 비구조화
    - 비구조화로 배열 또는 객체의 값을 새 변수에 더 쉽게 할당 가능
- import and export
- Promise
    - 비동기 코드 쓰는 방법
    - api에서 데이터를 가져오거나 실행하는데 시간이 걸리는 함수를 가지고 있을 때 사용 가능
- 나머지 매개 변수 및 확산 연산자
    - 나머지 매개 변수는 배열의 인수를 가져오고 새 배열을 반환하는데 사용
    - 확산 연산자는 나머지 매개변수와 구문이 동일하지만 인수 뿐만 아니라 배열 자체를 가짐
- Class
    - OOP의 핵심
    - 코드를 더욱 안전하게 캡슐화 가능
    - 코드 구조가 좋아지고 방향 유지

### ES6 버전 호환이 안되는 브라우저 해결 방법

**폴리필**

> 특정 기능이 브라우저에서 지원되지 않을 때 기능을 대신할 수 있는 코드를 제공하는 라이브러리
> 

→ ES6 이상의 기능을 지원하지 않는 브라우저에서도 최신 기능 사용 가능

→ 모든 사용자에게 추가되는 코드라 성능에 영향을 줄 수 있음

→ 사용하지 않는거 추천

**트랜스파일**

> 최신 JS 코드를 하위 호환되는 버전의 코드로 변환하는 작업
> 

→ 이를 위해 Babel 같은 트랜스 파일러 도구 사용

→ **Babel?**

- ES6 이상의 코드를 ES5 버전의 코드로 변환해줌
- 프로젝트에 babel 설정 후 이를 통해 코드 변환
- webpack 같은 번들러와 함께 사용해 빌드 프로세스에서 자동으로 트랜스파일링 가능

→ Babel 사용 시 변환된 코드의 성능이 원본 코드보다 낮을 수 있음

→ 특정 ES6 기능은 이걸로 지원되지 않으므로 폴리필과 함께 사용하는 것이 필요할지도

## var, let, const 차이점

### var

- 중복 선언과 재할당 모두 가능
- 마지막에 할당된 값이 최종으로 변수의 값으로 저장됨
- 함수 단위 스코프
- var가 선언된 함수 내부의 어디서든 참조 가능, 외부로는 참조 불가능
- 호이스팅 발생 → 뒤에 선언된 변수가 앞에 참조되어도 에러가 아닌 undefined 호출

### let

- 중복 선언 허용 x
- 중복 선언할 경우 SyntaxError 발생
- 블록 단위 스코프
- { } 블록 내부에서 선언된 변수는 외부에서 참조 x
- 호이스팅 발생 (다르게 작동) → 뒤에 선언된 변수가 앞에 참조하려고 하면 에러 발생
- 호이스팅을 발생하지만 값을 참조할 수 없어서 동작하지 않는 것처럼 보임

### const

- 중복 선언 허용 x
- 재할당 x
- 블록 단위 스코프
- { } 블록 내부에서 선언된 변수는 외부에서 참조 x
- 호이스팅 발생 (다르게 작동) → 뒤에 선언된 변수가 앞에 참조하려고 하면 에러 발생
- 호이스팅을 발생하지만 값을 참조할 수 없어서 동작하지 않는 것처럼 보임

## var, let의 범위 차이

<aside>
💡 **var**는 ****변수를 블록을 고려하지 않고 현재 함수 어디에서나 접근할 수 있는 변수 선언
**let**은 ****블록 명령문이나 let을 사용한 표현식 내로 범위가 재한되는 변수 선언

</aside>

## TDZ

### TDZ란?

> Temporal Dead Zone = 일시적 사각 지대
> 

```jsx
const dog = "누룽"
console.log(dog)
```

```jsx
console.log(dog)
const dog = "누룽"
```

⇒ TDZ란 변수 선언 및 초기화 전 사이의 사각지대

⇒ 변수 선언 및 초기화 하기 전에 사용하게 되면 TDZ 상태에서 사용하는 것이라 ReferenceError가 뜸

### TDZ의 영향

**영향을 미치는 것**

> const, let, class → 순서 주의

TDZ는 선언하기 전에 변수를 사용하는 것을 허용하지 않음
> 

**영향을 미치지 않는 것**

> var, function, import

var는 선언 전에도 사용할 수 있어 코드가 엉키거나 오류의 원인이 될 수도..
따라서 var는 피하고 let과 const 사용을 주로 하는걸로!
> 

## 호이스팅

### 호이스팅?

<aside>
💡 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것

</aside>

자바스크립트 내 변수와 함수의 선언 순서에 상관 없이 순서가 끌어올려진 듯한 현상

- var로 선언한 변수의 경우 호이스팅 시 undefined로 변수 초기화
- let과 const로 선언한 변수의 경우 호이스팅 시 변수 초기화 x

### 함수 호이스팅

```jsx
Nurung();

function Nurung() {
	document.writeln("Nurung!");
}

Nurung();
```

호이스팅 개념 없이 생각해보면 실행되지 않아야 하지만,,

JS 함수는 Hoisting하기 때문에 최상단의 `Nurung()`코드도 정상 작동

### 변수 호이스팅

**var로 선언**

```jsx
console.log(nurung);
var nurung = "nurungss";
console.log(nurung);
```

→ undefined 출력

**const, let으로 선언**

```jsx
console.log(nurung);
const nurung = "nurungss";

console.log(nurung);
let nurung = "nurungss";
```

→ ReferenceError

에러는 발생했지만 호이스팅이 안되는게 아님..
let, const로 선언한 변수는 호이스팅 되었지만 접근만 하지 못하게 된 것!! (TDZ)

## 현재 있는 곳을 객체로 추상화하면?

교실

### 객체의 속성

- 이름
- 학생 목록
- 선생님
- 최대 수용 인원
- 과목

### 객체의 메서드

- 학생 추가
- 학생 제거
- 학생 목록 조회
- 교실 정보 조회
- 수업 시작
